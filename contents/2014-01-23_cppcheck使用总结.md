早就想给ichanged来个静态检查，今天终于想起来了，用的是cppcheck，暴露的问题没有想象中的多但是也不少，c++确实写的也不多，现在刚好来总结一下子。：）
</br></br>

####引用传递参数  
  
cppcheck给出的警告：
![此处输入图片的描述][1]  
从这个警告展开引出了两个问题（第二个问题是解答，第一个问题只是偶然看到的）：

- 赋值函数（对对象赋值操作的函数set_xxx）返回值应该用引用传递对象
- 也是effective c++中提到的，非内置类型和STL中迭代器，最好用引用传递代替值传递  
</br>
    
首先说第一个问题，也就是赋值函数。也就是以下这种：
![此处输入图片的描述][2]   
  

这种存在于对象之间的赋值最好选择使用引用，为什么呢？就拿这里说，我们都知道string是一个对象，不是内置类型，我们之所以可以使用=号进行相互赋值，是因为我们在类里面定义了operetor =的操作。而相应的，effective c++中也有提到，建议在operator =中返回this指针，可以看下string类operator =的实现，代码《高质量c++/c编程指南》中有。  
因此在这个return到外部的过程中，this指针拷贝并保存到外部的存储单元中，也就增加了开销，降低赋值的效率，特别是类比较大的时候(string 比较大)。

<!--more-->  

ps: 另外补充一点，在使用operator +操作的时候，尽量使用值传递。
</br>  

然后是第二个问题，非内置类型和STL中迭代器，最好用引用传递代替值传递。effective c++中的条款20：宁以pass-by-reference-to-const代替pass-by-value，这里的作用域仍然是排除内置类型和STL中的迭代器。那么为什么呢？

例如这么一个函数:

    :::C++
    void Foo(string temp);
   

 我们在调用这个函数的时候，使用一个temp的副本，也就是说我们必须调用一次拷贝构造函数，当函数结束的时候就会调用一次析构函数，更坏的情况，如果这个类里还有别  的类，那我们会调用很多次构造函数，很多次析构函数，所以尽量使用传引用。  
</br>  

####构造函数

构造函数记得初始化全部的变量。

</br>
####变量的作用域
还是习惯用c的风格，要注意了，在需要的位置定义变量。



  [1]: http://pic.yupoo.com/fayewu_v/DtSL52Wv/8Guri.png
  [2]: http://pic.yupoo.com/fayewu_v/DtYFHdq6/cpVkW.png
