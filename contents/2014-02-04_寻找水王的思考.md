《编程之美》上有个寻找发贴水王的题，其实刨除了这些题干，是等同于以下这个问题的，也就是说有个数组，里面有很多数字，其中有重复，这个数组里一个确定的数字超过了半数，求出这个数字。

- 我们可能很快就注意到，“超过了半数”是一个可以入手的点。最直接的方法是：
我们将这个数组排序，那么中间的那个必然是这个数字。  

- 第二个是哈希表，我们可以把数字当作键值，然后value为统计次数，最后再扫一编。这样子复杂度是控制在O(n)的，但也很显然，哈希表还需要额外O(n)的空间。

- 第三个是《编程之美》上给出的方法。是这么描述的：每次删除两个不同的数字，那么最后剩下的必然是超过半数的数字。（这个其实蛮好理解的。）  

        /*
         * 其实思路是这样的：一个数字超过半数，那这个数字足以匹配剩余小于半数的数字
         * 和其凑成两两一组（互不相同），最后剩下的必然是这个数字。
         */
        int
        foo(int array[], int length)
        {
	        int i, candidate, times = 0;

	        for (i = 0; i < length; i++) {
		        if (times == 0) {
			        candidate = a[i];
			        times = 1;
		        } else {
			        if (candidate == a[i]) {
				        times++;
			        } else {
				        times--;
			        }
		        }	
	        }

	        return candidate;	
        }

- 还有一个思路，其实这个问题也就是求中位数，（但求中位数并不一定需要排序。。快排中其实有个很重要的思想，就是每次取一个index位置，保证这个位置之前的都比他小，之后的都比他大。也就是说我们可以利用快排中这个部分来找中文数，如果index小于一半，则往后区间找。。

如果可能不存在这个数字的话，那么最终还需要扫一遍。如果确定有这个数字，那就可以不用扫这一遍了，


